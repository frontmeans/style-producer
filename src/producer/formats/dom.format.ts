import { RenderScheduler } from '@proc7ts/render-scheduler';
import { StypFormat } from '../format';
import { removeStyleElement, stypRenderScheduler } from './format.impl';
/**
 * @packageDocumentation
 * @module @proc7ts/style-producer
 */
import { stypTextFormat, StypTextFormatConfig } from './text.format';

/**
 * Configuration of {@link stypDomFormat DOM style production format}.
 *
 * @category Rendering
 */
export interface StypDomFormatConfig extends StypTextFormatConfig {

  /**
   * Document to add style elements to.
   *
   * `parent.ownerDocument` or `window.document` by default.
   */
  readonly document?: Document;

  /**
   * Parent DOM node to add stylesheets to.
   *
   * `document.head` by default.
   *
   * This node don't have to be attached to document.
   */
  readonly parent?: Node;

  /**
   * DOM rendering operations scheduler.
   *
   * Creates a render schedule per rule.
   *
   * Uses `newRenderSchedule` for [[parent]] node by default.
   */
  readonly scheduler?: RenderScheduler;

}

/**
 * Builds DOM style production format.
 *
 * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and fills it with CSS text
 * generated by {@link stypTextFormat textual CSS production format}.
 *
 * This format is generally slower than {@link stypObjectFormat CSS object model production format}, but allows to add
 * `<style>` elements to DOM node outside document. E.g. to `DocumentFragment`.
 *
 * @category Rendering
 * @param config  DOM style format configuration.
 *
 * @returns CSS production format.
 */
export function stypDomFormat(
    config: StypDomFormatConfig = {},
): StypFormat {

  const {
    document = config.parent?.ownerDocument || window.document,
    parent = document.head,
  } = config;
  const textFormat = stypTextFormat(config);
  const elements = new Map<string, HTMLStyleElement>();
  const supply = textFormat.onSheet(({ id, css }) => {

    let element = elements.get(id);

    if (css == null) { // Element always exists here
      elements.delete(id);
      removeStyleElement(element!);
    } else if (!element) {
      element = document.createElement('style');
      element.setAttribute('type', 'text/css');
      element.textContent = css;
      parent.appendChild(element);
      elements.set(id, element);
      supply.whenOff(() => removeStyleElement(element!));
    } else {
      element.textContent = css;
    }
  });

  return {
    ...config,
    scheduler: stypRenderScheduler(parent, config.scheduler),
    addSheet(producer) {
      supply.needs(producer);
      this.addSheet = textFormat.addSheet.bind(textFormat);
      return this.addSheet(producer);
    },
  };
}
