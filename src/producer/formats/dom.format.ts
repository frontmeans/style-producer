import { RenderScheduler } from '@frontmeans/render-scheduler';
import { StypFormat } from '../format';
import { removeStyleElement, stypRenderScheduler } from './format.impl';
import { stypTextFormat, StypTextFormatConfig } from './text.format';

/**
 * Configuration of {@link stypDomFormat DOM style production format}.
 *
 * @category Rendering
 */
export interface StypDomFormatConfig extends StypTextFormatConfig {
  /**
   * Document to add style elements to.
   *
   * `parent.ownerDocument` or `window.document` by default.
   */
  readonly document?: Document | undefined;

  /**
   * Parent DOM node to add stylesheets to.
   *
   * `document.head` by default.
   *
   * This node don't have to be attached to document.
   */
  readonly parent?: Node | undefined;

  /**
   * DOM rendering operations scheduler.
   *
   * Creates a render schedule per rule.
   *
   * Uses `newRenderSchedule` for {@link parent} node by default.
   */
  readonly scheduler?: RenderScheduler | undefined;
}

/**
 * Builds DOM style production format.
 *
 * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and fills it with CSS text
 * generated by {@link stypTextFormat textual CSS production format}.
 *
 * This format is generally slower than {@link stypObjectFormat CSS object model production format}, but allows to add
 * `<style>` elements to DOM node outside document. E.g. to `DocumentFragment`.
 *
 * @category Rendering
 * @param config - DOM style format configuration.
 *
 * @returns CSS production format.
 */
export function stypDomFormat(config: StypDomFormatConfig = {}): StypFormat {
  const { document = config.parent?.ownerDocument || window.document, parent = document.head } =
    config;
  const textFormat = stypTextFormat(config);
  const scheduler = stypRenderScheduler(parent, config.scheduler);
  const schedule = scheduler();
  const elements = new Map<string, HTMLStyleElement>();
  const supply = textFormat.onSheet(({ id, css }) => {
    // CSS text is reported within schedule. No need to re-schedule DOM manipulations here.

    let element = elements.get(id);

    if (css == null) {
      // element exists here
      elements.delete(id);
      removeStyleElement(element!);
    } else if (element) {
      element.textContent = css;
    } else {
      element = document.createElement('style');
      element.setAttribute('type', 'text/css');
      element.textContent = css;
      parent.appendChild(element);
      elements.set(id, element);
      supply.whenOff(
        // Schedule element removal on style sheet removal instead of removing it right away.
        () => schedule(() => removeStyleElement(element!)),
      );
    }
  });

  return {
    ...config,
    scheduler,
    addSheet(producer) {
      supply.needs(producer);
      this.addSheet = textFormat.addSheet.bind(textFormat);

      return this.addSheet(producer);
    },
  };
}
